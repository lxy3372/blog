<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Riky]]></title>
  <subtitle><![CDATA[Keep it simple.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://rikyliu.com/"/>
  <updated>2016-02-28T13:20:58.000Z</updated>
  <id>http://rikyliu.com/</id>
  
  <author>
    <name><![CDATA[Riky Liu]]></name>
    <email><![CDATA[me@rikyliu.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[linux笔记：NFS的使用]]></title>
    <link href="http://rikyliu.com/linux-nfs/"/>
    <id>http://rikyliu.com/linux-nfs/</id>
    <published>2015-12-03T09:42:06.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>填坑不易，且填且珍惜！幸亏最近自己有整理相关的文档，有些东西自己在脑海里整理过一遍写出来，基本就不会忘记了，即使是有些偏差还是可以修正，加深印象。</p>
<p>先说说为什么会使用上NFS（Network File System, 作为一个小白程序猿，之前真的压根就没有听说过这玩意儿，我果然很菜），网站之前的服务器部署一直只有一台服务器（lnmp一键安装了），随然流量的增大，除了做一些软性的优化之外（缓存），我逐渐将Redis和Mysql迁移到了另一台服务器，以减少主站的压力。在此基础上考虑到可能会推一些引流的活动，以备用为目的申请了一台备用主机。以此为契机，我开始研究Nginx的负载均衡（之后整理下负载均衡的配置），成功的将主站服务器和备用 服务器纳入集群中。那这时候问题就来了：</p>
<ol>
<li>备用主机没有外网IP，网站一些爬虫无法请求到外网；</li>
<li>因为没有使用第三方存储，上传的图片一致存储在主站的静态资源目录，以images.rikyliu.com的形式去访问。虽然通过nginx转发到备用主机可以上传上去，但是此主机没有外网IP，无法访问其静态资源。</li>
</ol>
<p>虽然这两个问题都可以用nginx的proxy_pass来转发到主站服务器解决，但是当一些接口逻辑涉及到文件处理时却不是很方便，于是我找到了NFS来解决此问题：<br><img src="http://7xi3xm.com1.z0.glb.clouddn.com/server.jpg" alt="服务器架构"><br><a id="more"></a></p>
<p>如图所示，存储图片的主机开机NFS Server服务，将文件存储目录设置NFS 网络共享盘。然后备用主机将NFS Server的共享盘挂载在当前服务器的同一目录，从而实现从不同服务器上传文件，都可以进行存储和读取。</p>
<p>以下是（Ubuntu）基本的安装是使用：</p>
<h2 id="主服务器：服务端（内网：192-168-1-1）:">主服务器：服务端（内网：192.168.1.1）:</h2><p>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></p>
<p>编辑:vim /etc/exports<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数：</span></span><br><span class="line"><span class="comment">#共享目录   ip(权限)</span></span><br><span class="line">/data/upload <span class="number">192.168</span>.<span class="number">1.2</span>(rw,sync,no_root_squash,no_subtree_check,insecure)</span><br><span class="line">/data/web/webapi_v2/upload </span><br><span class="line"><span class="comment">#权限参数详情：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rw  可读写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sync 同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#no_root_squash   登入 NFS 主机使用分享目录的使用者，如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限！这个项目『极不安全』，不建议使用！</span></span><br><span class="line"><span class="comment">#root_squash：在登入 NFS 主机使用分享之目录的使用者如果是 root 时，那么这个使用者的权限将被压缩成为匿名使用者，通常他的 UID 与 GID 都会变成 nobody 那个系统账号的身份。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sync 资料同步写入到内存与硬盘当中 </span></span><br><span class="line"><span class="comment">#async 资料会先暂存于内存当中，而非直接写入硬盘 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#insecure 允许从这台机器过来的非授权访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#no_subtree_check: 即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；</span></span><br><span class="line"><span class="comment">#subtree_check: 若输出目录是一个子目录，则nfs服务器将检查其父目录的权限；</span></span><br></pre></td></tr></table></figure></p>
<p>重启nfs-kernel-server<br>具体参数可参考<a href="http://www.cnblogs.com/lykyl/archive/2013/06/14/3136921.html" target="_blank" rel="external">cnblogs</a></p>
<h2 id="备用服务器：客户端（内网：192-168-1-2）">备用服务器：客户端（内网：192.168.1.2）</h2><p>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common</span><br></pre></td></tr></table></figure></p>
<p>挂载:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs <span class="number">192.168</span>.<span class="number">1.1</span>:/data/upload  /data/upload <span class="comment">#将192.168.1.1主机/data/upload 目录 挂载到目录/data/upload 下</span></span><br></pre></td></tr></table></figure></p>
<p>酱紫，进入/data/upload 目录就可以看到192.168.1.1对应目录下的文件了，具体权限 请参考上面的参数设置即可。</p>
<p>这样就可以了么？还不够，如果主机重启了的话，还得手动挂载，所以需要在开机启动中设置自动挂载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line">UUID=af414ad8-<span class="number">9936</span>-<span class="number">46</span><span class="built_in">cd</span>-b074-<span class="number">528854656</span>fcd / ext4 errors=remount-ro <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>:/data/upload /data/upload nfs defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>以上就是最近我自己在使用NFS过程中得到的一些经验，如果有不对的地方，请及时指正，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[ubuntu下NFS搭建]]>
    
    </summary>
    
      <category term="NFS" scheme="http://rikyliu.com/tags/NFS/"/>
    
      <category term="linux" scheme="http://rikyliu.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux笔记：SVN]]></title>
    <link href="http://rikyliu.com/linux-svn-gitbook/"/>
    <id>http://rikyliu.com/linux-svn-gitbook/</id>
    <published>2015-12-01T07:31:27.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>由于公司木有运维，什么事都需要自己动手来做。在一步步搭建开发环境的过程中总是会遇到很多选择和坑。首当其冲的便是版本控制的选择：Git和SVN。<br>虽然我个人偏向于Git（GitLab或者Gitblit，之后会提到这些，毕竟是我自己经常使用的）。今天说说SVN：<br>安装就不用说了，除了一些较为复杂的软件，安装命令都是容易想得到的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install subversion</span><br></pre></td></tr></table></figure></p>
<p>用SVN是大家讨论后得出的结果，我也觉得有两点在SVN上比较好用：</p>
<ol>
<li>利用SVN部署DEV环境的web服务</li>
<li>利用SVN部署WIKI,这里我采用的是<a href="http://www.gitbook.com" target="_blank" rel="external">GitBook</a>。(这是个不错的玩意儿)</li>
</ol>
<p>先记录下SVN安装SVN之后一些必要的操作：</p>
<h4 id="1-_创建仓库">1. 创建仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo svnadmin create /data/svn/web  <span class="comment">#缺省，细节参数未曾研究</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>之后会在该目录下生成一下目录大致如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── conf  <span class="comment">#配置文件目录</span></span><br><span class="line">│   ├── authz <span class="comment">#用户和组配置</span></span><br><span class="line">│   ├── hooks-env.tmpl</span><br><span class="line">│   ├── passwd <span class="comment">#用户账号密码</span></span><br><span class="line">│   └── svnserve.conf  <span class="comment">#svn服务配置(项目和系统相关)</span></span><br><span class="line">├── db</span><br><span class="line">├── format</span><br><span class="line">├── hooks <span class="comment">#hooks这个很重要</span></span><br><span class="line">│   ├── post-commit.tmpl</span><br><span class="line">│   ├── post-lock.tmpl</span><br><span class="line">│   ├── post-revprop-change.tmpl</span><br><span class="line">│   ├── post-unlock.tmpl</span><br><span class="line">│   ├── pre-commit.tmpl</span><br><span class="line">│   ├── pre-lock.tmpl</span><br><span class="line">│   ├── pre-revprop-change.tmpl</span><br><span class="line">│   ├── pre-unlock.tmpl</span><br><span class="line">│   ├── start-commit.tmpl</span><br><span class="line">│   └── test.log</span><br><span class="line">├── locks</span><br><span class="line">└── README.tx</span><br></pre></td></tr></table></figure></p>
<h6 id="1-1_conf基本配置">1.1 conf基本配置</h6><ul>
<li><p>authz 配置用户组和读写权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加：</span></span><br><span class="line">[groups]</span><br><span class="line">dev = dev,riky <span class="comment">#用户所属组</span></span><br><span class="line">[/]</span><br><span class="line">@dev = rw <span class="comment">#组配置权限(简单的配置)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>passwd 配置账号和密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置用户账号密码</span></span><br><span class="line">[users]</span><br><span class="line">riky = riky</span><br><span class="line">dev = dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>svnserve.conf 这个文件我没有做什么修改</p>
</li>
</ul>
<p>酱紫基本svn服务就可以起起来了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#svn服务器目录/data/svn/web/  端口 3691</span></span><br><span class="line">sudo svnserve <span class="operator">-d</span> -T -r /data/svn/web/ --listen-port <span class="number">3691</span></span><br></pre></td></tr></table></figure></p>
<h6 id="1-2_利用hooks自动部署Web和WIKI">1.2 利用hooks自动部署Web和WIKI</h6><p>服务端启动了就可以检出到服务器web目录（<code>cd /data/web</code>）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn checkout svn://<span class="number">192.168</span>.<span class="number">1.1</span>:<span class="number">3691</span> <span class="comment">#检出整个目录</span></span><br><span class="line"><span class="comment">#然后提交几个测试文件上去即可</span></span><br><span class="line">touch test.txt</span><br><span class="line">svn add test.txt</span><br><span class="line">svn ci * -m<span class="string">"init"</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以利用hooks了：</p>
<ul>
<li>将上述hooks中post-commit.tmpl 重命名为post-commit</li>
<li>编辑添加以下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-<span class="number">8</span></span><br><span class="line">SVN=/usr/bin/svn</span><br><span class="line"><span class="built_in">cd</span> /data/web  <span class="comment">#web客户端根目录</span></span><br><span class="line"><span class="variable">$SVN</span> update</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>保存之后，在其他电脑上检出svn，并提交php文件，就会在当前目录自动更新，实现SVN提交代码即可在Web服务器上生效了。</p>
<h4 id="2-_开机启动">2. 开机启动</h4><p>为了避免停机后出现的麻烦,可以将svn启动加入到启动脚本中：<br>在/etc/init.d/下创建svn.sh:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">svnserve <span class="operator">-d</span> --listen-port <span class="number">3691</span> -T -r /data/svn/web/</span><br><span class="line"><span class="comment">#如果有多个svn仓库，可以加入多个</span></span><br></pre></td></tr></table></figure></p>
<p>在/etc/rs.local中添加如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/svn.sh <span class="comment">#新加入，需放在exit前</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>重启服务器即可生效。<br>以上就是最近在整服务器的时候一些摸索出来的配置，至于准不准备我也不太确定！总之，之后看到的时候还是能有一些帮助的，一些更细节性的配置以后在修正。</p>
]]></content>
    <summary type="html">
    <![CDATA[linux学习笔记，svn和gitbook]]>
    
    </summary>
    
      <category term="svn" scheme="http://rikyliu.com/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux笔记:创建用户和私钥登陆]]></title>
    <link href="http://rikyliu.com/linux-note/"/>
    <id>http://rikyliu.com/linux-note/</id>
    <published>2015-11-30T08:08:45.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>最近侥幸获得一台低配版的阿里云主机，虽然是低配但是练练手也是挺好的。自从进入“某爱”之后，我开始不再只是程序猿了，居然还是“搞机”的运维狗，无奈啊，公司的云主机都是我一个一个Google然后配起来的，虽然不是很标准，但最起码还是能用的。趁此机会将之前倒腾过的部分技能重新梳理下，免得到时候又给忘记了。</p>
<h4 id="注册新用户">注册新用户</h4><p>通过Root登录之后第一件事就是创建一个属于自己的用户，然后把root这个账号登录权限关闭了。防止被攻击（之前在不懂事的时候就被攻击了）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser username<span class="comment">#后续输入密码，即可（可填项跳过）</span></span><br></pre></td></tr></table></figure></p>
<p>这个地方我之前踩过一个坑，那就是<strong> <code>adduser</code> </strong> 和 <strong><code>useradd</code></strong>是有区别的，区别在于useradd仅仅只是创建了一个用户，没有密码。而<code>adduser</code>会为用户做许多准备工作：</p>
<ol>
<li>需要输入密码</li>
<li>建立与当前创建用户名相同的group</li>
<li>会在home目录下建立用户目录，用户登陆之后的默认目录就是这个，<code>cd ~</code>也是回到这个目录</li>
<li>最重要的是可以通过SSH登陆了，其他就不太清楚了</li>
</ol>
<p>酱紫，基本上就可以用自己的账号密码登陆了<code>ssh user@ip</code>。<br><a id="more"></a></p>
<h4 id="SSH私钥登陆">SSH私钥登陆</h4><ol>
<li>先生成本地密钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -C <span class="string">"your email"</span> <span class="comment">#命令后续存在交互，一般回车忽略</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>主目录下<code>~/.ssh</code>文件夹中会生成对应<code>id_rsa</code>(私钥)和<code>id_rsa.pub</code>(公钥)</p>
<ol>
<li>上传公钥到服务器<br>网上较多的说法是scp上传id_rsa.pub到服务器上<code>~/.ssh/authorized_keys</code>,然后更改该文件权限为600即可，我试过并不好使。最简洁的方式是使用<code>ssh-copy-id</code>即可。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id  -i id_rsa.pub  user@ip</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>酱紫就可以直接用私钥登陆了。</p>
<ol>
<li>关闭root登陆和密码认证<br>为了服务器安全，我经常选择关闭掉root的登陆权限和密码登陆权限，更改两项配置即可<code>vim /etc/ssh/sshd_config</code>：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">PermitRootLogin</span> <span class="built_in">no</span>  <span class="comment">#文件最后两行 将yes改为no</span></span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line">PasswordAuthentication <span class="built_in">no</span>  <span class="comment">#最后一行 将yes改为no</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>保存后重启即可<code>sudo reboot</code><br><strong> 这里需要记下的一点的是，修改改文件需要管理员权限，而经过上述创建的用户，并不是sudoers也就是无法通过使用sudo来更改此文件 </strong></p>
<ol>
<li>配置sudoers权限<br>该文件配置项还是比较多的，我只是想用户能用即可，其他的坑待以后来填，已root用户身份登陆<code>su</code>，编辑<code>/etc/sudoers</code>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">username ALL=(ALL:ALL) ALL <span class="comment">#新添加</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>保存后就可以使用了，以上就是一些创建用户的基本上要做的（个人走过的路而已，已在高速上大神勿喷）。<br><strong>注： 关闭密码登陆而使用私钥登陆之后，请做好私钥备份。免得到时候私钥弄丢了，进不去就悲剧了</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[Linux运维笔记]]>
    
    </summary>
    
      <category term="adduser" scheme="http://rikyliu.com/tags/adduser/"/>
    
      <category term="linux" scheme="http://rikyliu.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://rikyliu.com/tags/ssh/"/>
    
      <category term="ssh-copy-id" scheme="http://rikyliu.com/tags/ssh-copy-id/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[客户端设置多个github账号]]></title>
    <link href="http://rikyliu.com/git-github-account/"/>
    <id>http://rikyliu.com/git-github-account/</id>
    <published>2015-04-22T14:33:31.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>最近由于需要在自己的电脑上办公，需要远程连接公司的Gitblit。但本机已经简单的配置GitHub的一些账号信息。在两个账号切换的过程中会有些麻烦，于是Google下，有了以下的解决方案：</p>
<h4 id="（参考:_http://www-cnblogs-com/sosoft/p/3477578-html）">（参考: <a href="http://www.cnblogs.com/sosoft/p/3477578.html）" target="_blank" rel="external">http://www.cnblogs.com/sosoft/p/3477578.html）</a></h4><h3 id="步骤一：用ssh-keygen命令生成一组新的id_rsa_new和id_rsa_new-pub。">步骤一：用<code>ssh-keygen</code>命令生成一组新的id_rsa_new和id_rsa_new.pub。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#34;new email&#34;</span><br></pre></td></tr></table></figure>
<p>平时我们都是直接回车，默认生成id_rsa和id_rsa.pub。这里特别需要注意，出现提示输入文件名的时候要输入与默认配置不一样的文件名，比如： id_rsa_new。</p>
<h3 id="步骤二：配置~/-ssh/config文件，以我自己的机器为例。">步骤二：配置~/.ssh/config文件，以我自己的机器为例。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Default Git&#10;&#10;Host chdxy# &#27604;&#22914; chdxy&#10;&#10;HostName IP Address #&#19968;&#33324;&#37319;&#29992;&#23545;&#24212;&#22495;&#21517;&#21363;&#21487;  github.com&#10;&#10;User think #&#35813;&#29992;&#25143;&#20026;github&#36134;&#25143;&#29992;&#25143;&#21517;  &#22914;  CHDTEAM&#10;&#10;IdentityFile ~/.ssh/id_rsa&#10;&#10;#Second Git   &#21516;&#19978;&#37197;&#32622;&#37319;&#29992;&#19968;&#26679;&#30340;&#21363;&#21487;&#10;&#10;Host secondgit&#10;&#10;HostName IP Address #&#22495;&#21517;&#20063;&#21487;&#10;&#10;User think&#10;&#10;IdentityFile ~/.ssh/id_rsa_second</span><br></pre></td></tr></table></figure>
<p>Host就是每个SSH连接的单独代号，IdentityFile告诉SSH连接去读取哪个私钥。</p>
<h3 id="步骤三：执行ssh-agent让ssh识别新的私钥。">步骤三：执行ssh-agent让ssh识别新的私钥。</h3><a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># &#22810;&#20010;&#36134;&#21495;&#30340;ssh-key &#37117;&#38656;&#35201;&#21152;&#36827;&#26469;&#10;&#10;#&#26368;&#22909;&#20808;&#27979;&#35797;&#19979;&#26159;&#21542;&#36830;&#25509;&#25104;&#21151;  ssh -T git@chdxy   &#65288;&#19968;&#33324;&#40664;&#35748;&#20026;git@github.com &#27492;&#22788;&#35774;&#32622;&#20102;Host&#65292;&#37319;&#29992;&#33258;&#24049;&#36134;&#21495;&#30340;Host&#21363;&#21487;&#65289;&#10;&#10;ssh-add ~/.ssh/id_rsa_new&#10;ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>该命令如果报错：Could not open a connection to your authentication agent.无法连接到ssh agent，可执行ssh-agent bash命令后再执行ssh-add命令。<br>以后，在clone或者add remote的时候，需要把config文件中的host代替git@remoteaddress中的remoteaddress。</p>
<p>同时，你可以通过在特定的repo下执行下面的命令，生成区别于全局设置的user.name和user.email。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &#34;newname&#34;&#10;&#10;git config user.email &#34;newemail&#34;&#10;&#10;#git config --global --unset user.name &#21462;&#28040;&#20840;&#23616;&#35774;&#32622;&#10;&#10;#git config --global --unset user.email &#21462;&#28040;&#20840;&#23616;&#35774;&#32622;&#10;&#10;#&#22312;&#21516;&#19968;&#26426;&#22120;&#19981;&#21516;&#30446;&#24405;&#19979;&#20811;&#38534;&#36828;&#31243;&#21516;&#19968;&#20010;repo</span><br></pre></td></tr></table></figure></p>
<p>然后执行对应的clone操作就可以了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/user1&#10;&#10;git clone git@chdxy/chdxy:xxx.git   #&#26684;&#24335;  git clone git@Host:&#29992;&#25143;&#21517;/&#20855;&#20307;.git   &#21363;&#25226;&#40664;&#35748;&#30340;github.com &#25913;&#25104; &#8220;Host&#8221;&#10;&#10;cd /home/user2&#10;git clone git@secondgit:User/xxx.git</span><br></pre></td></tr></table></figure>
<p>上面的两条clone命令，虽然关联到同一个repo，却是通过不同ssh连接，当然也是不同的git账号。<br>注意：以上不要设置全局的user 和email 直接设置当前仓库的user 和email即可 （去掉—global，如果已设置加上—unset参数即可）</p>
<p>接下来的各种操作（pull、push、fetch和普通的一样）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[客户端git配置多个github账号]]>
    
    </summary>
    
      <category term="Git" scheme="http://rikyliu.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://rikyliu.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单的进程启动和关闭Shell脚本制作]]></title>
    <link href="http://rikyliu.com/php-fpm-shell/"/>
    <id>http://rikyliu.com/php-fpm-shell/</id>
    <published>2015-04-22T14:12:55.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>整个Shell相对简单，重点理解<code>awk</code> ，管道<code>|</code>,以及 <code>xargs kill -9</code> 应该就比较清晰了，<br>整个过程就是一个查询-&gt;筛选-&gt;然后kill-&gt;到在启动的过程，其他服务如Redis,MongoDB,Memecache以及Mysql和Apache都可以用类似的方式来制作简单的Shell脚本。<br>使用相对简单：<code>./php-fpm.sh start</code><br>如果不能放到/bin/bash目录，可以采用软连接<code>ln -s</code>或者别名<code>alias fpm=&#39;/usr/local/bash/php-fpm.sh&#39;</code>的方式来简化命令操作：</p>
<h4 id="别名：">别名：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令行操作即可</span></span><br><span class="line"><span class="comment">#输出到.bashrc</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias phpfpm='/usr/local/bash/php-fpm'"</span>&gt;&gt;~/.bashrc</span><br><span class="line"><span class="comment">#使其生效</span></span><br><span class="line">soure ~/.bashrc</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>脚本源码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#从终端接收第一个参数，系统本身默认当前shel为第0个参数$0</span></span><br><span class="line">param=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动进程函数</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">#执行进程查询</span></span><br><span class="line">	<span class="comment">#ps aux  查询所用用户进程</span></span><br><span class="line">	<span class="comment">#grep -i "php-fpm"  查询进程为php-fpm的进程，不区分大小写</span></span><br><span class="line">	<span class="comment">#grep -v grep 移除查询结果中存在grep的进程，即忽略当前查询进程</span></span><br><span class="line">	<span class="comment">#awk '&#123;print $2&#125;' 打印第二列参数</span></span><br><span class="line">    fpms=`ps aux | grep -i <span class="string">"php-fpm"</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"></span><br><span class="line">	<span class="comment">#当前进程不为空  -n ： 字符串不为空</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$fpms</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="comment">#启动进程</span></span><br><span class="line">        php-fpm</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"PHP-FPM Start"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"PHP-FPM Already Start"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">#停止进程</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    fpms=`ps aux | grep -i <span class="string">"php-fpm"</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">	<span class="comment">#xargs 将  前面 $fpms 作为kill的参数，执行kill进程操作</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$fpms</span> | xargs <span class="built_in">kill</span> -<span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pid <span class="keyword">in</span> <span class="variable">$fpms</span>; <span class="keyword">do</span></span><br><span class="line">		<span class="comment">#正则匹配非数字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$pid</span> | egrep -q <span class="string">'^[0-9]+$'</span>; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"PHP-FPM Pid <span class="variable">$pid</span> Kill"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"<span class="variable">$pid</span> IS Not A PHP-FPM Pid"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#switch 调用 </span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$param</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">'start'</span>)</span><br><span class="line">        start;;</span><br><span class="line">    <span class="string">'stop'</span>)</span><br><span class="line">        stop;;</span><br><span class="line">    <span class="string">'restart'</span>)</span><br><span class="line">        stop</span><br><span class="line">        start;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Usage: ./phpfpm.sh start|stop|restart"</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[php-fpm.sh 启动脚本制作]]>
    
    </summary>
    
      <category term="php" scheme="http://rikyliu.com/tags/php/"/>
    
      <category term="shell" scheme="http://rikyliu.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP简单类型转换及类型函数判断下的区别]]></title>
    <link href="http://rikyliu.com/php-empty-empty-boolval-isset/"/>
    <id>http://rikyliu.com/php-empty-empty-boolval-isset/</id>
    <published>2015-04-01T14:58:02.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>公司后端用Java重构后已经有几个月没写过PHP了，虽然PHP不是很出色的语言，但也是我进入工作后的第一语言，我也没打算放弃它。前那两天看到一个关于类型判断的帖子，觉得挺有趣的，虽然不复杂，却也挺考验PHP基础的功底的。</p>
<p>函数 <em><code>gettype(), empty(), is_null(), isset(), boolval()</code></em> 这几个在获取参数判断类型上常用的方法，感觉还是特别容易出错的，因此我在自己测试了之后总结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>gettype()</th>
<th>empty()</th>
<th>is_null()</th>
<th>isset()</th>
<th>boolval()</th>
</tr>
</thead>
<tbody>
<tr>
<td>$val=””;</td>
<td>String</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>$val=null;</td>
<td>NULL</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>var $val</td>
<td>NULL</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>$val=array()</td>
<td>Array</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>$val=false;</td>
<td>boolean</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>$var=1</td>
<td>int</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>$var=0</td>
<td>int</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>$var=-1</td>
<td>int</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>$var=”9”</td>
<td>string</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>$var=”0”</td>
<td>string</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>$var=”hello”</td>
<td>string</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>$val=”ture”</td>
<td>string</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>$val=”false”</td>
<td>string</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>以上是正确的格式对照表。<br><a id="more"></a></p>
<h5 id="我自己在测试的过程中也出现了一些疑问：">我自己在测试的过程中也出现了一些疑问：</h5><ol>
<li><p>bool值false在判断是否为空时，显示为空</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$val</span>=<span class="keyword">false</span>; </span><br><span class="line">var_dump(<span class="keyword">empty</span>(<span class="variable">$val</span>));</span><br><span class="line"><span class="comment">#print bool（true）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数字0在判断为空是，显示为true</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$val</span>=<span class="number">0</span>;</span><br><span class="line">var_dump(<span class="keyword">empty</span>(<span class="variable">$val</span>));</span><br><span class="line"><span class="comment">#print bool(true）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串0在判断为空是，显示为true</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$val</span>=<span class="string">"0"</span>;</span><br><span class="line">var_dump(<span class="keyword">empty</span>(<span class="variable">$val</span>));</span><br><span class="line"><span class="comment">#print bool(true）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更重要的是<code>$val=&quot;&quot;;</code>和<code>$val=&quot;0&quot;;</code>的判断的结果是一样的，这些我可以通过PHP的弱类型自动转换来解释，但之后我做了一个简单的实验，一时无法让我开窍了：<br><img src="http://7xi3xm.com1.z0.glb.clouddn.com/php.jpg" alt="php代码"><br>按图上的推理逻辑，<code>&#39;&#39;</code>那就应该是等于<code>&#39;0&#39;</code>了，这难道是我自己钻了牛角尖么？<br>答案是确实是自己走进了死胡同，PHP在不同类型做比较的时候会进行转换，但相同类型则没有转换成false的问题，因此就出现了这种让自己觉得可笑的事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[PHP简单类型转换及类型函数gettype(), empty(), is_null(), isset(), boolval()的区别]]>
    
    </summary>
    
      <category term="PHP" scheme="http://rikyliu.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MyBatis动态SQL优化方案之@UpdateProvider]]></title>
    <link href="http://rikyliu.com/java-mybatis/"/>
    <id>http://rikyliu.com/java-mybatis/</id>
    <published>2015-03-30T22:09:31.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>   最近开始学习纯注解形式的MyBatis，我很是喜爱（从动态的PHP转到Java对配置XML这种配置的从个人感情上很是厌恶,不喜勿喷哈），网上也有不少教程，但普遍性的就都是<code>@Select</code>、<code>@Update</code>、<code>@Delete</code>以及<code>@SelectKey</code>的一些简单的用法的介绍。</p>
<p>   当然这些以满足了简单的SQL逻辑。但是当遇到多个简单的更新不同的字段的时候，便显得显得冗余了。一般的解决的办法是，不断重载一个更新方法，更新简单的字段。还有更甚的是一次更新全部字段。其实如果用Xml配置的话，是有相关的语法通过判断字段是否为空来判断是否需要更新的。<br>类似：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;select id="findByPage" parameterType="com.user.util.PageUtil" resultType="com.user.dao.UserDaoImpl" &gt;</span><br><span class="line">		select * from user where 1 = 1 </span><br><span class="line">		&lt;if email="email!= "" || email!= null"&gt;</span><br><span class="line">			    and ename = #&#123;user.email&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">		...</span><br></pre></td></tr></table></figure></p>
<p>其实注解形式通过<code>@UpdateProvider</code>也是能够解决这个问题的。<br><a id="more"></a><br>当使用Mapper时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Select</span>(<span class="string">"SELECT * FROM user WHERE user_id = #&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function">User <span class="title">getUserById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@UpdateProvider</span>(type = UserSql.class, method = <span class="string">"update"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立对应的UserSql.java文件：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSql</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(<span class="keyword">final</span> User user)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				UPDATE(<span class="string">"user"</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//通过条件 判断是否需要更新该字段</span></span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line">					SET(<span class="string">"name = #&#123;name&#125;"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotBlank(user.getNickName()))&#123;</span><br><span class="line">					SET(<span class="string">"name = #&#123;nickName&#125;"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotBlank(user.getEmail()))&#123;</span><br><span class="line">					SET(<span class="string">"name = #&#123;email&#125;"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				...</span><br><span class="line">				</span><br><span class="line">				WHERE(<span class="string">"id = #&#123;id&#125;"</span>)</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样基本上就实现了通过对字段的判断实现动态的拼接了。</p>
]]></content>
    <summary type="html">
    <![CDATA[MyBatis动态SQL优化方案之@UpdateProvider]]>
    
    </summary>
    
      <category term="Java" scheme="http://rikyliu.com/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://rikyliu.com/tags/MyBatis/"/>
    
      <category term="UpdateProvider" scheme="http://rikyliu.com/tags/UpdateProvider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开始使用Hexo搭建博客]]></title>
    <link href="http://rikyliu.com/hexo/"/>
    <id>http://rikyliu.com/hexo/</id>
    <published>2015-03-25T22:33:49.000Z</published>
    <updated>2016-02-28T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p>告别wordpress之后，我一直在寻找代替品，试过复杂的Jetty，也试过其他基于LAMP的CMS，最终选择了Hexo，安装也不算复杂：</p>
<ol>
<li><p>安装Node.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node  <span class="comment">#OS X 环境</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Hexo</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后就可以在本地初始化博客了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment">#此间会提示你npm install </span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件_config.yml 配置站点信息,这个比较简单</p>
<a id="more"></a></li>
<li><p>生成新的文章</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"标题"</span> <span class="comment">#会在source/_post 下生成对应的md文件，采用markdown编辑器编辑即可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后生成静态化站点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要发布的Github上，先在配置文件中配置好Github信息，这里需要现在github账号下创建项目blog（注意不要创建README）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">      <span class="built_in">type</span>: github <span class="comment">#3.0之后 为git</span></span><br><span class="line">      repository: https://github.com/lxy3372/blog.git</span><br><span class="line">      branch: gh-pages</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo deploy --generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意项（爬坑）</p>
</li>
</ol>
<h5 id="安装插件">安装插件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装 RSS 和 sitemap相关插件</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment">#save不能丢，否则一直不会生效</span></span><br></pre></td></tr></table></figure>
<h5 id="Github相关CNAME">Github相关CNAME</h5><p>如果直接在github上创建该文件，每次发布时，这个文件都会被覆盖掉，解决办法是在source下建立CNAME文件，每次发布都会push上去。</p>
<h5 id="添加站内搜索">添加站内搜索</h5><p><a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype.html" target="_blank" rel="external">利用swiftype为hexo添加站内搜索</a>  该博客已经成功添加，但我按照此方法实现搜索时，在搜索页遇到部分JS问题，无法异步加载数据到Search页面。</p>
<hr>
<p>杂记：<br>   在折腾期间也遇到了一些问题，比如编辑_config.yml的时候，如果用vim编辑的话，在启动server的时候会出现格式错误的问题，而直接用文本编辑则不会出现这种问题，这可能跟我vim的配置有些关系。该文也是我参考了其他朋友的文章，按自己搭建的顺序写的，也算是重复造轮子了，不过当Markdown练练手也是不错的。</p>
]]></content>
    <summary type="html">
    <![CDATA[Hexo使用心得]]>
    
    </summary>
    
      <category term="blog" scheme="http://rikyliu.com/tags/blog/"/>
    
      <category term="hexo" scheme="http://rikyliu.com/tags/hexo/"/>
    
      <category term="mac" scheme="http://rikyliu.com/tags/mac/"/>
    
      <category term="蜕变" scheme="http://rikyliu.com/tags/%E8%9C%95%E5%8F%98/"/>
    
  </entry>
  
</feed>